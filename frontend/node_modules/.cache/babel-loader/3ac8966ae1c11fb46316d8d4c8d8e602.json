{"ast":null,"code":"import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { useRef, useEffect } from 'react';\nimport { Keys } from '../components/keyboard.esm.js';\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management.esm.js';\nimport { useWindowEvent } from './use-window-event.esm.js';\nimport { useIsMounted } from './use-is-mounted.esm.js';\nvar Features;\n(function (Features) {\n  /** No features enabled for the `useFocusTrap` hook. */\n  Features[Features[\"None\"] = 1] = \"None\";\n  /** Ensure that we move focus initially into the container. */\n\n  Features[Features[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n\n  Features[Features[\"TabLock\"] = 4] = \"TabLock\";\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n\n  Features[Features[\"FocusLock\"] = 8] = \"FocusLock\";\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n\n  Features[Features[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  /** Enable all features. */\n\n  Features[Features[\"All\"] = 30] = \"All\";\n})(Features || (Features = {}));\nfunction useFocusTrap(container, features, _temp) {\n  if (features === void 0) {\n    features = Features.All;\n  }\n  var _ref = _temp === void 0 ? {} : _temp,\n    initialFocus = _ref.initialFocus,\n    containers = _ref.containers;\n  var restoreElement = useRef(typeof window !== 'undefined' ? document.activeElement : null);\n  var previousActiveElement = useRef(null);\n  var mounted = useIsMounted();\n  var featuresRestoreFocus = Boolean(features & Features.RestoreFocus);\n  var featuresInitialFocus = Boolean(features & Features.InitialFocus); // Capture the currently focused element, before we enable the focus trap.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    restoreElement.current = document.activeElement;\n  }, [featuresRestoreFocus]); // Restore the focus when we unmount the component.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    return function () {\n      focusElement(restoreElement.current);\n      restoreElement.current = null;\n    };\n  }, [featuresRestoreFocus]); // Handle initial focus\n\n  useEffect(function () {\n    if (!featuresInitialFocus) return;\n    if (!container.current) return;\n    var activeElement = document.activeElement;\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n        previousActiveElement.current = activeElement;\n        return; // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement;\n      return; // Already focused within Dialog\n    } // Try to focus the initialFocus ref\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      focusElement(initialFocus.current);\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />');\n      }\n    }\n    previousActiveElement.current = document.activeElement;\n  }, [container, initialFocus, featuresInitialFocus]); // Handle `Tab` & `Shift+Tab` keyboard events\n\n  useWindowEvent('keydown', function (event) {\n    if (!(features & Features.TabLock)) return;\n    if (!container.current) return;\n    if (event.key !== Keys.Tab) return;\n    event.preventDefault();\n    if (focusIn(container.current, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround) === FocusResult.Success) {\n      previousActiveElement.current = document.activeElement;\n    }\n  }); // Prevent programmatically escaping the container\n\n  useWindowEvent('focus', function (event) {\n    if (!(features & Features.FocusLock)) return;\n    var allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    if (!allContainers.size) return;\n    var previous = previousActiveElement.current;\n    if (!previous) return;\n    if (!mounted.current) return;\n    var toElement = event.target;\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\nfunction contains(containers, element) {\n  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {\n    var _container$current;\n    var container = _step.value;\n    if ((_container$current = container.current) == null ? void 0 : _container$current.contains(element)) return true;\n  }\n  return false;\n}\nexport { Features, useFocusTrap };","map":{"version":3,"names":["Features","useFocusTrap","container","features","_temp","All","initialFocus","_ref","containers","restoreElement","useRef","window","document","activeElement","previousActiveElement","mounted","useIsMounted","featuresRestoreFocus","Boolean","RestoreFocus","featuresInitialFocus","InitialFocus","useEffect","current","focusElement","contains","focusIn","Focus","First","FocusResult","Error","console","warn","useWindowEvent","event","TabLock","key","Keys","Tab","preventDefault","shiftKey","Previous","Next","WrapAround","Success","FocusLock","allContainers","Set","add","size","previous","toElement","target","HTMLElement","stopPropagation","element","_iterator","_createForOfIteratorHelperLoose","_step","done","_container$current","value"],"sources":["/Users/flok/Documents/Check/indexcards.ai/frontend/node_modules/@headlessui/react/src/hooks/use-focus-trap.ts"],"sourcesContent":["import {\n  useRef,\n  // Types\n  MutableRefObject,\n  useEffect,\n} from 'react'\n\nimport { Keys } from '../components/keyboard'\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management'\nimport { useWindowEvent } from './use-window-event'\nimport { useIsMounted } from './use-is-mounted'\n\nexport enum Features {\n  /** No features enabled for the `useFocusTrap` hook. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n  RestoreFocus = 1 << 4,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\nexport function useFocusTrap(\n  container: MutableRefObject<HTMLElement | null>,\n  features: Features = Features.All,\n  {\n    initialFocus,\n    containers,\n  }: {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    containers?: MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n  } = {}\n) {\n  let restoreElement = useRef<HTMLElement | null>(\n    typeof window !== 'undefined' ? (document.activeElement as HTMLElement) : null\n  )\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n  let mounted = useIsMounted()\n\n  let featuresRestoreFocus = Boolean(features & Features.RestoreFocus)\n  let featuresInitialFocus = Boolean(features & Features.InitialFocus)\n\n  // Capture the currently focused element, before we enable the focus trap.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    restoreElement.current = document.activeElement as HTMLElement\n  }, [featuresRestoreFocus])\n\n  // Restore the focus when we unmount the component.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    return () => {\n      focusElement(restoreElement.current)\n      restoreElement.current = null\n    }\n  }, [featuresRestoreFocus])\n\n  // Handle initial focus\n  useEffect(() => {\n    if (!featuresInitialFocus) return\n    if (!container.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n\n    if (initialFocus?.current) {\n      if (initialFocus?.current === activeElement) {\n        previousActiveElement.current = activeElement\n        return // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement\n      return // Already focused within Dialog\n    }\n\n    // Try to focus the initialFocus ref\n    if (initialFocus?.current) {\n      focusElement(initialFocus.current)\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n    }\n\n    previousActiveElement.current = document.activeElement as HTMLElement\n  }, [container, initialFocus, featuresInitialFocus])\n\n  // Handle `Tab` & `Shift+Tab` keyboard events\n  useWindowEvent('keydown', event => {\n    if (!(features & Features.TabLock)) return\n\n    if (!container.current) return\n    if (event.key !== Keys.Tab) return\n\n    event.preventDefault()\n\n    if (\n      focusIn(\n        container.current,\n        (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround\n      ) === FocusResult.Success\n    ) {\n      previousActiveElement.current = document.activeElement as HTMLElement\n    }\n  })\n\n  // Prevent programmatically escaping the container\n  useWindowEvent(\n    'focus',\n    event => {\n      if (!(features & Features.FocusLock)) return\n\n      let allContainers = new Set(containers?.current)\n      allContainers.add(container)\n\n      if (!allContainers.size) return\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n      if (!mounted.current) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<MutableRefObject<HTMLElement | null>>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.current?.contains(element)) return true\n  }\n\n  return false\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}