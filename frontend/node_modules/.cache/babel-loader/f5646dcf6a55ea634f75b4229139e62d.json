{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { Fragment, isValidElement, cloneElement, createElement, forwardRef } from 'react';\nimport { match } from './match.esm.js';\nvar Features;\n(function (Features) {\n  /** No features at all */\n  Features[Features[\"None\"] = 0] = \"None\";\n  /**\r\n   * When used, this will allow us to use one of the render strategies.\r\n   *\r\n   * **The render strategies are:**\r\n   *    - **Unmount**   _(Will unmount the component.)_\r\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\r\n   */\n\n  Features[Features[\"RenderStrategy\"] = 1] = \"RenderStrategy\";\n  /**\r\n   * When used, this will allow the user of our component to be in control. This can be used when\r\n   * you want to transition based on some state.\r\n   */\n\n  Features[Features[\"Static\"] = 2] = \"Static\";\n})(Features || (Features = {}));\nvar RenderStrategy;\n(function (RenderStrategy) {\n  RenderStrategy[RenderStrategy[\"Unmount\"] = 0] = \"Unmount\";\n  RenderStrategy[RenderStrategy[\"Hidden\"] = 1] = \"Hidden\";\n})(RenderStrategy || (RenderStrategy = {}));\nfunction render(_ref) {\n  var props = _ref.props,\n    slot = _ref.slot,\n    defaultTag = _ref.defaultTag,\n    features = _ref.features,\n    _ref$visible = _ref.visible,\n    visible = _ref$visible === void 0 ? true : _ref$visible,\n    name = _ref.name;\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name);\n  var featureFlags = features != null ? features : Features.None;\n  if (featureFlags & Features.Static) {\n    var _props$static = props[\"static\"],\n      isStatic = _props$static === void 0 ? false : _props$static,\n      rest = _objectWithoutPropertiesLoose(props, [\"static\"]); // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n\n    if (isStatic) return _render(rest, slot, defaultTag, name);\n  }\n  if (featureFlags & Features.RenderStrategy) {\n    var _match;\n    var _props$unmount = props.unmount,\n      unmount = _props$unmount === void 0 ? true : _props$unmount,\n      _rest = _objectWithoutPropertiesLoose(props, [\"unmount\"]);\n    var strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      return null;\n    }, _match[RenderStrategy.Hidden] = function () {\n      return _render(_extends({}, _rest, {\n        hidden: true,\n        style: {\n          display: 'none'\n        }\n      }), slot, defaultTag, name);\n    }, _match));\n  } // No features enabled, just render\n\n  return _render(props, slot, defaultTag, name);\n}\nfunction _render(props, slot, tag, name) {\n  var _ref2;\n  if (slot === void 0) {\n    slot = {};\n  }\n  var _omit = omit(props, ['unmount', 'static']),\n    _omit$as = _omit.as,\n    Component = _omit$as === void 0 ? tag : _omit$as,\n    children = _omit.children,\n    _omit$refName = _omit.refName,\n    refName = _omit$refName === void 0 ? 'ref' : _omit$refName,\n    passThroughProps = _objectWithoutPropertiesLoose(_omit, [\"as\", \"children\", \"refName\"]); // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n\n  var refRelatedProps = props.ref !== undefined ? (_ref2 = {}, _ref2[refName] = props.ref, _ref2) : {};\n  var resolvedChildren = typeof children === 'function' ? children(slot) : children; // Allow for className to be a function with the slot as the contents\n\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    passThroughProps.className = passThroughProps.className(slot);\n  }\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (!isValidElement(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error(['Passing props on \"Fragment\"!', '', \"The current component <\" + name + \" /> is rendering a \\\"Fragment\\\".\", \"However we need to passthrough the following props:\", Object.keys(passThroughProps).map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n'), '', 'You can apply a few solutions:', ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', 'Render a single element as the child so that we can forward the props onto that element.'].map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n')].join('\\n'));\n      }\n      return cloneElement(resolvedChildren, Object.assign({},\n      // Filter out undefined values so that they don't override the existing values\n      mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, ['onClick']), refRelatedProps));\n    }\n  }\n  return createElement(Component, Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps), resolvedChildren);\n}\n/**\r\n * We can use this function for the following useCase:\r\n *\r\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\r\n *\r\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\r\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\r\n * first child, that one should _also_ be called (but before this implementation, it was just\r\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\r\n * props of this component.\r\n *\r\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\r\n * so that we can refactor this later (if needed).\r\n */\n\nfunction mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {\n  var clone = Object.assign({}, passThroughProps);\n  var _loop = function _loop() {\n    var func = _step.value;\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      var _Object$assign;\n      Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {\n        // Props we control\n        if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component\n\n        if (!event.defaultPrevented) existingProps[func](event);\n      }, _Object$assign));\n    }\n  };\n  for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {\n    _loop();\n  }\n  return clone;\n}\n/**\r\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\r\n * wrap it in a forwardRef so that we _can_ passthrough the ref\r\n */\n\nfunction forwardRefWithAs(component) {\n  var _component$displayNam;\n  return Object.assign(forwardRef(component), {\n    displayName: (_component$displayNam = component.displayName) != null ? _component$displayNam : component.name\n  });\n}\nfunction compact(object) {\n  var clone = Object.assign({}, object);\n  for (var key in clone) {\n    if (clone[key] === undefined) delete clone[key];\n  }\n  return clone;\n}\nfunction omit(object, keysToOmit) {\n  if (keysToOmit === void 0) {\n    keysToOmit = [];\n  }\n  var clone = Object.assign({}, object);\n  for (var _iterator2 = _createForOfIteratorHelperLoose(keysToOmit), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n    if (key in clone) delete clone[key];\n  }\n  return clone;\n}\nexport { Features, RenderStrategy, forwardRefWithAs, render };","map":{"version":3,"names":["Features","RenderStrategy","render","_ref","props","slot","defaultTag","features","visible","_ref$visible","name","_render","featureFlags","None","Static","_props$static","isStatic","rest","_objectWithoutPropertiesLoose","_match","_props$unmount","unmount","_rest","strategy","Unmount","Hidden","match","_extends","hidden","style","display","tag","omit","as","Component","_omit$as","children","_omit","refName","_omit$refName","passThroughProps","refRelatedProps","ref","undefined","_ref2","resolvedChildren","className","Fragment","Object","keys","length","isValidElement","Array","isArray","Error","map","line","join","cloneElement","assign","mergeEventFunctions","compact","createElement","existingProps","functionsToMerge","clone","func","_step","value","_Object$assign","event","defaultPrevented","_iterator","_createForOfIteratorHelperLoose","done","_loop","forwardRefWithAs","component","forwardRef","displayName","_component$displayNam","object","key","keysToOmit","_iterator2","_step2"],"sources":["/Users/flok/Documents/Check/indexcards.ai/frontend/node_modules/@headlessui/react/src/utils/render.ts"],"sourcesContent":["import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}