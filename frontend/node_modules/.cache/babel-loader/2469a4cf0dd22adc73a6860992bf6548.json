{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport React, { useState, useMemo, useEffect, Fragment, useContext, createContext, useRef, useCallback } from 'react';\nimport { match } from '../../utils/match.esm.js';\nimport { render, RenderStrategy, Features } from '../../utils/render.esm.js';\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect.esm.js';\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete.esm.js';\nimport { useId } from '../../hooks/use-id.esm.js';\nimport { useIsMounted } from '../../hooks/use-is-mounted.esm.js';\nimport { useOpenClosed, State, OpenClosedProvider } from '../../internal/open-closed.esm.js';\nimport { useIsInitialRender } from '../../hooks/use-is-initial-render.esm.js';\nimport { transition, Reason } from './utils/transition.esm.js';\nfunction useSplitClasses(classes) {\n  if (classes === void 0) {\n    classes = '';\n  }\n  return useMemo(function () {\n    return classes.split(' ').filter(function (className) {\n      return className.trim().length > 1;\n    });\n  }, [classes]);\n}\nvar TransitionContext = /*#__PURE__*/createContext(null);\nTransitionContext.displayName = 'TransitionContext';\nvar TreeStates;\n(function (TreeStates) {\n  TreeStates[\"Visible\"] = \"visible\";\n  TreeStates[\"Hidden\"] = \"hidden\";\n})(TreeStates || (TreeStates = {}));\nfunction useTransitionContext() {\n  var context = useContext(TransitionContext);\n  if (context === null) {\n    throw new Error('A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.');\n  }\n  return context;\n}\nfunction useParentNesting() {\n  var context = useContext(NestingContext);\n  if (context === null) {\n    throw new Error('A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.');\n  }\n  return context;\n}\nvar NestingContext = /*#__PURE__*/createContext(null);\nNestingContext.displayName = 'NestingContext';\nfunction hasChildren(bag) {\n  if ('children' in bag) return hasChildren(bag.children);\n  return bag.current.filter(function (_ref) {\n    var state = _ref.state;\n    return state === TreeStates.Visible;\n  }).length > 0;\n}\nfunction useNesting(done) {\n  var doneRef = useRef(done);\n  var transitionableChildren = useRef([]);\n  var mounted = useIsMounted();\n  useEffect(function () {\n    doneRef.current = done;\n  }, [done]);\n  var unregister = useCallback(function (childId, strategy) {\n    var _match;\n    if (strategy === void 0) {\n      strategy = RenderStrategy.Hidden;\n    }\n    var idx = transitionableChildren.current.findIndex(function (_ref2) {\n      var id = _ref2.id;\n      return id === childId;\n    });\n    if (idx === -1) return;\n    match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      transitionableChildren.current.splice(idx, 1);\n    }, _match[RenderStrategy.Hidden] = function () {\n      transitionableChildren.current[idx].state = TreeStates.Hidden;\n    }, _match));\n    if (!hasChildren(transitionableChildren) && mounted.current) {\n      doneRef.current == null ? void 0 : doneRef.current();\n    }\n  }, [doneRef, mounted, transitionableChildren]);\n  var register = useCallback(function (childId) {\n    var child = transitionableChildren.current.find(function (_ref3) {\n      var id = _ref3.id;\n      return id === childId;\n    });\n    if (!child) {\n      transitionableChildren.current.push({\n        id: childId,\n        state: TreeStates.Visible\n      });\n    } else if (child.state !== TreeStates.Visible) {\n      child.state = TreeStates.Visible;\n    }\n    return function () {\n      return unregister(childId, RenderStrategy.Unmount);\n    };\n  }, [transitionableChildren, unregister]);\n  return useMemo(function () {\n    return {\n      children: transitionableChildren,\n      register: register,\n      unregister: unregister\n    };\n  }, [register, unregister, transitionableChildren]);\n}\nfunction noop() {}\nvar eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'];\nfunction ensureEventHooksExist(events) {\n  var result = {};\n  for (var _iterator = _createForOfIteratorHelperLoose(eventNames), _step; !(_step = _iterator()).done;) {\n    var _events$name;\n    var name = _step.value;\n    result[name] = (_events$name = events[name]) != null ? _events$name : noop;\n  }\n  return result;\n}\nfunction useEvents(events) {\n  var eventsRef = useRef(ensureEventHooksExist(events));\n  useEffect(function () {\n    eventsRef.current = ensureEventHooksExist(events);\n  }, [events]);\n  return eventsRef;\n} // ---\n\nvar DEFAULT_TRANSITION_CHILD_TAG = 'div';\nvar TransitionChildRenderFeatures = Features.RenderStrategy;\nfunction TransitionChild(props) {\n  var _match3;\n  var beforeEnter = props.beforeEnter,\n    afterEnter = props.afterEnter,\n    beforeLeave = props.beforeLeave,\n    afterLeave = props.afterLeave,\n    enter = props.enter,\n    enterFrom = props.enterFrom,\n    enterTo = props.enterTo,\n    entered = props.entered,\n    leave = props.leave,\n    leaveFrom = props.leaveFrom,\n    leaveTo = props.leaveTo,\n    rest = _objectWithoutPropertiesLoose(props, [\"beforeEnter\", \"afterEnter\", \"beforeLeave\", \"afterLeave\", \"enter\", \"enterFrom\", \"enterTo\", \"entered\", \"leave\", \"leaveFrom\", \"leaveTo\"]);\n  var container = useRef(null);\n  var _useState = useState(TreeStates.Visible),\n    state = _useState[0],\n    setState = _useState[1];\n  var strategy = rest.unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n  var _useTransitionContext = useTransitionContext(),\n    show = _useTransitionContext.show,\n    appear = _useTransitionContext.appear,\n    initial = _useTransitionContext.initial;\n  var _useParentNesting = useParentNesting(),\n    register = _useParentNesting.register,\n    unregister = _useParentNesting.unregister;\n  var id = useId();\n  var isTransitioning = useRef(false);\n  var nesting = useNesting(function () {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    if (!isTransitioning.current) {\n      setState(TreeStates.Hidden);\n      unregister(id);\n      events.current.afterLeave();\n    }\n  });\n  useIsoMorphicEffect(function () {\n    if (!id) return;\n    return register(id);\n  }, [register, id]);\n  useIsoMorphicEffect(function () {\n    var _match2;\n\n    // If we are in another mode than the Hidden mode then ignore\n    if (strategy !== RenderStrategy.Hidden) return;\n    if (!id) return; // Make sure that we are visible\n\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible);\n      return;\n    }\n    match(state, (_match2 = {}, _match2[TreeStates.Hidden] = function () {\n      return unregister(id);\n    }, _match2[TreeStates.Visible] = function () {\n      return register(id);\n    }, _match2));\n  }, [state, id, register, unregister, show, strategy]);\n  var enterClasses = useSplitClasses(enter);\n  var enterFromClasses = useSplitClasses(enterFrom);\n  var enterToClasses = useSplitClasses(enterTo);\n  var enteredClasses = useSplitClasses(entered);\n  var leaveClasses = useSplitClasses(leave);\n  var leaveFromClasses = useSplitClasses(leaveFrom);\n  var leaveToClasses = useSplitClasses(leaveTo);\n  var events = useEvents({\n    beforeEnter: beforeEnter,\n    afterEnter: afterEnter,\n    beforeLeave: beforeLeave,\n    afterLeave: afterLeave\n  });\n  var ready = useServerHandoffComplete();\n  useEffect(function () {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?');\n    }\n  }, [container, state, ready]); // Skipping initial transition\n\n  var skip = initial && !appear;\n  useIsoMorphicEffect(function () {\n    var node = container.current;\n    if (!node) return;\n    if (skip) return;\n    isTransitioning.current = true;\n    if (show) events.current.beforeEnter();\n    if (!show) events.current.beforeLeave();\n    return show ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, function (reason) {\n      isTransitioning.current = false;\n      if (reason === Reason.Finished) events.current.afterEnter();\n    }) : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, function (reason) {\n      isTransitioning.current = false;\n      if (reason !== Reason.Finished) return; // When we don't have children anymore we can safely unregister from the parent and hide\n      // ourselves.\n\n      if (!hasChildren(nesting)) {\n        setState(TreeStates.Hidden);\n        unregister(id);\n        events.current.afterLeave();\n      }\n    });\n  }, [events, id, isTransitioning, unregister, nesting, container, skip, show, enterClasses, enterFromClasses, enterToClasses, leaveClasses, leaveFromClasses, leaveToClasses]);\n  var propsWeControl = {\n    ref: container\n  };\n  var passthroughProps = rest;\n  return React.createElement(NestingContext.Provider, {\n    value: nesting\n  }, React.createElement(OpenClosedProvider, {\n    value: match(state, (_match3 = {}, _match3[TreeStates.Visible] = State.Open, _match3[TreeStates.Hidden] = State.Closed, _match3))\n  }, render({\n    props: _extends({}, passthroughProps, propsWeControl),\n    defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n    features: TransitionChildRenderFeatures,\n    visible: state === TreeStates.Visible,\n    name: 'Transition.Child'\n  })));\n}\nfunction Transition(props) {\n  // @ts-expect-error\n  var show = props.show,\n    _props$appear = props.appear,\n    appear = _props$appear === void 0 ? false : _props$appear,\n    unmount = props.unmount,\n    passthroughProps = _objectWithoutPropertiesLoose(props, [\"show\", \"appear\", \"unmount\"]);\n  var usesOpenClosedState = useOpenClosed();\n  if (show === undefined && usesOpenClosedState !== null) {\n    var _match4;\n    show = match(usesOpenClosedState, (_match4 = {}, _match4[State.Open] = true, _match4[State.Closed] = false, _match4));\n  }\n  if (![true, false].includes(show)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.');\n  }\n  var _useState2 = useState(show ? TreeStates.Visible : TreeStates.Hidden),\n    state = _useState2[0],\n    setState = _useState2[1];\n  var nestingBag = useNesting(function () {\n    setState(TreeStates.Hidden);\n  });\n  var initial = useIsInitialRender();\n  var transitionBag = useMemo(function () {\n    return {\n      show: show,\n      appear: appear || !initial,\n      initial: initial\n    };\n  }, [show, appear, initial]);\n  useEffect(function () {\n    if (show) {\n      setState(TreeStates.Visible);\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden);\n    }\n  }, [show, nestingBag]);\n  var sharedProps = {\n    unmount: unmount\n  };\n  return React.createElement(NestingContext.Provider, {\n    value: nestingBag\n  }, React.createElement(TransitionContext.Provider, {\n    value: transitionBag\n  }, render({\n    props: _extends({}, sharedProps, {\n      as: Fragment,\n      children: React.createElement(TransitionChild, Object.assign({}, sharedProps, passthroughProps))\n    }),\n    defaultTag: Fragment,\n    features: TransitionChildRenderFeatures,\n    visible: state === TreeStates.Visible,\n    name: 'Transition'\n  })));\n}\nTransition.Child = function Child(props) {\n  var hasTransitionContext = useContext(TransitionContext) !== null;\n  var hasOpenClosedContext = useOpenClosed() !== null;\n  return !hasTransitionContext && hasOpenClosedContext ? React.createElement(Transition, Object.assign({}, props)) : React.createElement(TransitionChild, Object.assign({}, props));\n};\nTransition.Root = Transition;\nexport { Transition };","map":{"version":3,"names":["useSplitClasses","classes","useMemo","split","filter","className","trim","length","TransitionContext","createContext","displayName","TreeStates","useTransitionContext","context","useContext","Error","useParentNesting","NestingContext","hasChildren","bag","children","current","_ref","state","Visible","useNesting","done","doneRef","useRef","transitionableChildren","mounted","useIsMounted","useEffect","unregister","useCallback","childId","strategy","RenderStrategy","Hidden","idx","findIndex","_ref2","id","match","_match","Unmount","splice","register","child","find","_ref3","push","noop","eventNames","ensureEventHooksExist","events","result","_iterator","_createForOfIteratorHelperLoose","_step","_events$name","name","value","useEvents","eventsRef","DEFAULT_TRANSITION_CHILD_TAG","TransitionChildRenderFeatures","Features","TransitionChild","props","beforeEnter","afterEnter","beforeLeave","afterLeave","enter","enterFrom","enterTo","entered","leave","leaveFrom","leaveTo","rest","_objectWithoutPropertiesLoose","container","useState","_useState","setState","unmount","show","_useTransitionContext","appear","initial","_useParentNesting","useId","isTransitioning","nesting","useIsoMorphicEffect","_match2","enterClasses","enterFromClasses","enterToClasses","enteredClasses","leaveClasses","leaveFromClasses","leaveToClasses","ready","useServerHandoffComplete","skip","node","transition","reason","Reason","Finished","propsWeControl","ref","passthroughProps","React","createElement","Provider","OpenClosedProvider","_match3","State","Open","Closed","render","_extends","defaultTag","features","visible","Transition","_props$appear","usesOpenClosedState","useOpenClosed","undefined","_match4","includes","_useState2","nestingBag","useIsInitialRender","transitionBag","sharedProps","as","Fragment","Object","assign","Child","hasTransitionContext","hasOpenClosedContext","Root"],"sources":["/Users/flok/Documents/Check/indexcards.ai/frontend/node_modules/@headlessui/react/src/components/transitions/transition.tsx"],"sourcesContent":["import React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n} from 'react'\nimport { Props } from '../../types'\n\nimport { useId } from '../../hooks/use-id'\nimport { useIsInitialRender } from '../../hooks/use-is-initial-render'\nimport { match } from '../../utils/match'\nimport { useIsMounted } from '../../hooks/use-is-mounted'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\n\nimport { Features, PropsForFeatures, render, RenderStrategy } from '../../utils/render'\nimport { Reason, transition } from './utils/transition'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\n\ntype ID = ReturnType<typeof useId>\n\nfunction useSplitClasses(classes: string = '') {\n  return useMemo(() => classes.split(' ').filter(className => className.trim().length > 1), [\n    classes,\n  ])\n}\n\ninterface TransitionContextValues {\n  show: boolean\n  appear: boolean\n  initial: boolean\n}\nlet TransitionContext = createContext<TransitionContextValues | null>(null)\nTransitionContext.displayName = 'TransitionContext'\n\nenum TreeStates {\n  Visible = 'visible',\n  Hidden = 'hidden',\n}\n\nexport interface TransitionClasses {\n  enter?: string\n  enterFrom?: string\n  enterTo?: string\n  entered?: string\n  leave?: string\n  leaveFrom?: string\n  leaveTo?: string\n}\n\nexport interface TransitionEvents {\n  beforeEnter?: () => void\n  afterEnter?: () => void\n  beforeLeave?: () => void\n  afterLeave?: () => void\n}\n\ntype TransitionChildProps<TTag> = Props<TTag, TransitionChildRenderPropArg> &\n  PropsForFeatures<typeof TransitionChildRenderFeatures> &\n  TransitionClasses &\n  TransitionEvents & { appear?: boolean }\n\nfunction useTransitionContext() {\n  let context = useContext(TransitionContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\nfunction useParentNesting() {\n  let context = useContext(NestingContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\ninterface NestingContextValues {\n  children: MutableRefObject<{ id: ID; state: TreeStates }[]>\n  register: (id: ID) => () => void\n  unregister: (id: ID, strategy?: RenderStrategy) => void\n}\n\nlet NestingContext = createContext<NestingContextValues | null>(null)\nNestingContext.displayName = 'NestingContext'\n\nfunction hasChildren(\n  bag: NestingContextValues['children'] | { children: NestingContextValues['children'] }\n): boolean {\n  if ('children' in bag) return hasChildren(bag.children)\n  return bag.current.filter(({ state }) => state === TreeStates.Visible).length > 0\n}\n\nfunction useNesting(done?: () => void) {\n  let doneRef = useRef(done)\n  let transitionableChildren = useRef<NestingContextValues['children']['current']>([])\n  let mounted = useIsMounted()\n\n  useEffect(() => {\n    doneRef.current = done\n  }, [done])\n\n  let unregister = useCallback(\n    (childId: ID, strategy = RenderStrategy.Hidden) => {\n      let idx = transitionableChildren.current.findIndex(({ id }) => id === childId)\n      if (idx === -1) return\n\n      match(strategy, {\n        [RenderStrategy.Unmount]() {\n          transitionableChildren.current.splice(idx, 1)\n        },\n        [RenderStrategy.Hidden]() {\n          transitionableChildren.current[idx].state = TreeStates.Hidden\n        },\n      })\n\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        doneRef.current?.()\n      }\n    },\n    [doneRef, mounted, transitionableChildren]\n  )\n\n  let register = useCallback(\n    (childId: ID) => {\n      let child = transitionableChildren.current.find(({ id }) => id === childId)\n      if (!child) {\n        transitionableChildren.current.push({ id: childId, state: TreeStates.Visible })\n      } else if (child.state !== TreeStates.Visible) {\n        child.state = TreeStates.Visible\n      }\n\n      return () => unregister(childId, RenderStrategy.Unmount)\n    },\n    [transitionableChildren, unregister]\n  )\n\n  return useMemo(\n    () => ({\n      children: transitionableChildren,\n      register,\n      unregister,\n    }),\n    [register, unregister, transitionableChildren]\n  )\n}\n\nfunction noop() {}\nlet eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'] as const\nfunction ensureEventHooksExist(events: TransitionEvents) {\n  let result = {} as Record<keyof typeof events, () => void>\n  for (let name of eventNames) {\n    result[name] = events[name] ?? noop\n  }\n  return result\n}\n\nfunction useEvents(events: TransitionEvents) {\n  let eventsRef = useRef(ensureEventHooksExist(events))\n\n  useEffect(() => {\n    eventsRef.current = ensureEventHooksExist(events)\n  }, [events])\n\n  return eventsRef\n}\n\n// ---\n\nlet DEFAULT_TRANSITION_CHILD_TAG = 'div' as const\ntype TransitionChildRenderPropArg = MutableRefObject<HTMLDivElement>\nlet TransitionChildRenderFeatures = Features.RenderStrategy\n\nfunction TransitionChild<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let {\n    // Event \"handlers\"\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n\n    // Class names\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n\n    // @ts-expect-error\n    ...rest\n  } = props as typeof props\n  let container = useRef<HTMLElement | null>(null)\n  let [state, setState] = useState(TreeStates.Visible)\n  let strategy = rest.unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n  let { show, appear, initial } = useTransitionContext()\n  let { register, unregister } = useParentNesting()\n\n  let id = useId()\n\n  let isTransitioning = useRef(false)\n\n  let nesting = useNesting(() => {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    if (!isTransitioning.current) {\n      setState(TreeStates.Hidden)\n      unregister(id)\n      events.current.afterLeave()\n    }\n  })\n\n  useIsoMorphicEffect(() => {\n    if (!id) return\n    return register(id)\n  }, [register, id])\n\n  useIsoMorphicEffect(() => {\n    // If we are in another mode than the Hidden mode then ignore\n    if (strategy !== RenderStrategy.Hidden) return\n    if (!id) return\n\n    // Make sure that we are visible\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible)\n      return\n    }\n\n    match(state, {\n      [TreeStates.Hidden]: () => unregister(id),\n      [TreeStates.Visible]: () => register(id),\n    })\n  }, [state, id, register, unregister, show, strategy])\n\n  let enterClasses = useSplitClasses(enter)\n  let enterFromClasses = useSplitClasses(enterFrom)\n  let enterToClasses = useSplitClasses(enterTo)\n\n  let enteredClasses = useSplitClasses(entered)\n\n  let leaveClasses = useSplitClasses(leave)\n  let leaveFromClasses = useSplitClasses(leaveFrom)\n  let leaveToClasses = useSplitClasses(leaveTo)\n\n  let events = useEvents({ beforeEnter, afterEnter, beforeLeave, afterLeave })\n\n  let ready = useServerHandoffComplete()\n\n  useEffect(() => {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?')\n    }\n  }, [container, state, ready])\n\n  // Skipping initial transition\n  let skip = initial && !appear\n\n  useIsoMorphicEffect(() => {\n    let node = container.current\n    if (!node) return\n    if (skip) return\n\n    isTransitioning.current = true\n\n    if (show) events.current.beforeEnter()\n    if (!show) events.current.beforeLeave()\n\n    return show\n      ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n          if (reason === Reason.Finished) events.current.afterEnter()\n        })\n      : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n\n          if (reason !== Reason.Finished) return\n\n          // When we don't have children anymore we can safely unregister from the parent and hide\n          // ourselves.\n          if (!hasChildren(nesting)) {\n            setState(TreeStates.Hidden)\n            unregister(id)\n            events.current.afterLeave()\n          }\n        })\n  }, [\n    events,\n    id,\n    isTransitioning,\n    unregister,\n    nesting,\n    container,\n    skip,\n    show,\n    enterClasses,\n    enterFromClasses,\n    enterToClasses,\n    leaveClasses,\n    leaveFromClasses,\n    leaveToClasses,\n  ])\n\n  let propsWeControl = { ref: container }\n  let passthroughProps = rest\n\n  return (\n    <NestingContext.Provider value={nesting}>\n      <OpenClosedProvider\n        value={match(state, {\n          [TreeStates.Visible]: State.Open,\n          [TreeStates.Hidden]: State.Closed,\n        })}\n      >\n        {render({\n          props: { ...passthroughProps, ...propsWeControl },\n          defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition.Child',\n        })}\n      </OpenClosedProvider>\n    </NestingContext.Provider>\n  )\n}\n\nexport function Transition<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag> & { show?: boolean; appear?: boolean }\n) {\n  // @ts-expect-error\n  let { show, appear = false, unmount, ...passthroughProps } = props as typeof props\n\n  let usesOpenClosedState = useOpenClosed()\n\n  if (show === undefined && usesOpenClosedState !== null) {\n    show = match(usesOpenClosedState, {\n      [State.Open]: true,\n      [State.Closed]: false,\n    })\n  }\n\n  if (![true, false].includes((show as unknown) as boolean)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.')\n  }\n\n  let [state, setState] = useState(show ? TreeStates.Visible : TreeStates.Hidden)\n\n  let nestingBag = useNesting(() => {\n    setState(TreeStates.Hidden)\n  })\n\n  let initial = useIsInitialRender()\n  let transitionBag = useMemo<TransitionContextValues>(\n    () => ({ show: show as boolean, appear: appear || !initial, initial }),\n    [show, appear, initial]\n  )\n\n  useEffect(() => {\n    if (show) {\n      setState(TreeStates.Visible)\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden)\n    }\n  }, [show, nestingBag])\n\n  let sharedProps = { unmount }\n\n  return (\n    <NestingContext.Provider value={nestingBag}>\n      <TransitionContext.Provider value={transitionBag}>\n        {render({\n          props: {\n            ...sharedProps,\n            as: Fragment,\n            children: <TransitionChild {...sharedProps} {...passthroughProps} />,\n          },\n          defaultTag: Fragment,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition',\n        })}\n      </TransitionContext.Provider>\n    </NestingContext.Provider>\n  )\n}\n\nTransition.Child = function Child<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let hasTransitionContext = useContext(TransitionContext) !== null\n  let hasOpenClosedContext = useOpenClosed() !== null\n\n  return !hasTransitionContext && hasOpenClosedContext ? (\n    <Transition {...props} />\n  ) : (\n    <TransitionChild {...props} />\n  )\n}\nTransition.Root = Transition\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}